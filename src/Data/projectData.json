[
	{
		"title": "CrackEngine",
		"displayTitle": "CrackEngine: Custom C++ Engine",
		"summary": "A custom C++ game engine developed over six months by a small student team at TGA, built alongside the games that used it and improved iteratively across multiple projects.",
		"summaryVideo": {
			"name": "LarmetGickAbout",
			"link": "/media/larmet_gick/Showcase_larmet.mp4"
		},
		"introduction": "CrackEngine is a custom C++ game engine developed over six months by a small TGA student team, built in parallel with several student game projects. It features a full rendering pipeline built on DirectX 11, integrated physics, flexible gameplay systems, and editor support. The engine was iteratively improved project by project, enabling rapid prototyping, reliable reuse of core systems, and efficient iteration on gameplay features.",
		"introVideo": {
			"name": "LarmetGick Youtube Trailer",
			"link": "https://www.youtube.com/embed/s16y1qExd9Q"
		},
		"devTime": "6 Months",
		"engine": "C++",
		"genre": "Top-down diablo-style action game",
		"groupSize": "3-6",
		"sections": [

			{
				"name": "GameObject–Component System",
				"explenation": "The GameObject–Component System is the core of CrackEngine’s architecture, designed and implemented entirely by me. Inspired by Unity's component model, it allows gameplay elements to be composed flexibly: each scene consists of game objects, which can have multiple components and nested child objects. This modular system enables rapid iteration, reusable behaviors, and visual manipulation of objects directly in the editor. Components encapsulate functionality such as rendering, physics, input handling, and AI, and can be reused across different objects and projects.",
				"sections": [
					{
						"name": "GameObject–Component Code",
						"explenation": "This snippet demonstrates the core of the GameObject–Component System in CrackEngine. Components can be added to a GameObject dynamically using templates, and the system supports querying both single and multiple components of a given type. This design allows gameplay elements to be composed flexibly, enabling modular behaviors such as rendering, physics, AI, and input handling. The template and dynamic_cast usage ensures type safety while keeping the system generic and reusable across projects.",
						"code": [
							"// Adds a component of type T to this GameObject",
							"template<typename T = Component>",
							"void AddComponent(T* aComponent)",
							"{",
							"    myComponents.push_back(aComponent);",
							"    aComponent->SetOwner(this);",
							"}",
							"",
							"// Retrieves the first component of type T",
							"template<typename T = Component>",
							"T* GetComponent()",
							"{",
							"    for (auto& c : myComponents)",
							"    {",
							"        T* val = dynamic_cast<T*>(c);",
							"        if (val == nullptr) continue;",
							"        return val;",
							"    }",
							"    return nullptr;",
							"}",
							"",
							"// Retrieves all components of type T",
							"template<typename T = Component>",
							"std::vector<T*> GetComponents()",
							"{",
							"    std::vector<T*> components;",
							"    for (auto& c : myComponents)",
							"    {",
							"        T* val = dynamic_cast<T*>(c);",
							"        if (val == nullptr) continue;",
							"        components.push_back(val);",
							"    }",
							"    return components;",
							"}"
						],
						"language": "cpp"
					},
					{
						"name": "GameObject–Component Diagram",
						"explenation": "Diagram showing the hierarchy of GameObjects and Components in CrackEngine.",
						"image": {
							"name": "GameObjectComponentDiagram",
							"link": "/media/test/ducky.png"
						}
					}
				]
			},
			{
				"name": "Engine Editor",
				"explenation": "I built the editor backend for CrackEngine to support efficient development and iteration across all projects using the engine. It allows inspection and modification of GameObjects, component composition, transforms, hierarchies, and runtime states. This editor was central to the development workflow, enabling rapid iteration on enemies, player behavior, and interactive objects. The system was designed to integrate tightly with engine math, component management, and scene hierarchy.",
				"sections": [
					{
						"name": "Debug & Line Drawer",
						"explenation": "The editor integrates a 3D line drawing system for debugging, including custom shaders. These lines allow visualization of object positions, component data, and parent-child relationships in real-time, making scene setup and AI development easier. Debug logs are automatically excluded in release builds."
					},
					{
						"name": "Component Inspection",
						"explenation": "Components can be added, inspected, and modified directly in the editor. The system supports dynamic templates, allowing developers to attach multiple component types to GameObjects, query them individually or in groups, and edit properties at runtime. This made testing and iterating on game mechanics extremely efficient."
					},
					{
						"name": "Component Management Example",
						"explenation": "This snippet shows how the editor interacts with GameObjects to add and query components.",
						"code": [
							"THIS IS NOT A CODE SNIPPET YET ONLY A LITTLE TEST SO FAR"
						],
						"language": "cpp"
					},
					{
						"name": "Parent-Child & Drag-Drop",
						"explenation": "The editor supports robust drag-and-drop workflows, both internally and from the operating system. Assets such as models and textures can be dragged directly from Windows Explorer into the editor, where they are imported and instantiated using the engine’s asset and component systems.\n\nThe hierarchy view fully supports parent–child relationships. GameObjects can be reparented via drag-and-drop, with local and world transforms recalculated automatically to preserve spatial consistency. This behavior is driven by the engine’s transform and math systems, ensuring correct position, rotation, and scale propagation across complex hierarchies rather than relying on editor-specific overrides.",
						"video": {
							"name": "Gameobject Drag & Drop",
							"link": "/media/aeon/Aeon_PlayerMov.mp4"
						},
						"textArea": "left"
					},
					{
						"name": "Save & Load",
						"explenation": "The editor integrates with the engine's save/load system to persist scenes, object transforms, and component properties. All data is serialized to JSON, including hierarchical relationships, component types, and values, allowing scenes to be restored exactly as they were edited in the editor."
					}
				]
			},
			{
				"name": "PhysX Integration",
				"explenation": "I implemented the PhysX foundation, scene management, and simulation loop for CrackEngine. This includes fixed-timestep simulation, robust collision filtering, and routing collision events to gameplay components. The system was designed to remain stable under fluctuating frame rates while giving gameplay systems precise control over physics interactions.",
				"sections": [
					{
						"name": "Fixed Timestep Simulation",
						"explenation": "The physics simulation runs with a fixed timestep, capped at 60 updates per second, while still using accumulated frame delta time. This ensures consistent physics behavior even when the game experiences frame drops or stalls. The system also supports skipping a simulation frame when needed for special gameplay events, such as respawning or scene transitions."
					},
					{
						"name": "PhysX Update Loop",
						"explenation": "The PhysX scene is stepped using an accumulator-based fixed timestep. After simulation, collision data is processed and forwarded to gameplay components unless explicitly skipped for special cases.",
						"code": [
							"void PhysXManager::Update(float deltaTime)",
							"{",
							"    if (!myPxScene)",
							"        return;",
							"",
							"    myAccumulator += deltaTime;",
							"",
							"    if (myAccumulator < myTimeStep)",
							"        return;",
							"",
							"    myAccumulator -= myTimeStep;",
							"",
							"    myPxScene->simulate(myTimeStep);",
							"    myPxScene->fetchResults(true);",
							"",
							"    // Can skip giving contact data (used for respawn)",
							"    if (skipFrame)",
							"    {",
							"        std::queue<PairData> empty;",
							"        std::swap(myPairData, empty);",
							"        skipFrame = false;",
							"        return;",
							"    }",
							"    ",
							"    afterContact();",
							"}"
						],
						"language": "cpp"
					},
					{
						"name": "Collision Dispatch",
						"explenation": "Collision handling is performed after the physics simulation step. Contact pairs collected during simulation are filtered using PhysX filter data to determine which interactions should generate gameplay responses. This allows precise control over collision behavior while keeping gameplay systems decoupled from the physics layer.\n\nFiltered collisions are then routed to the appropriate components attached to the involved GameObjects, allowing different component types to respond to physics events without hard dependencies or tight coupling between systems.",
						"code": [
							"void PhysXManager::afterContact()",
							"{",
							"    while (!myPairData.empty())",
							"    {",
							"        const physx::PxContactPair* pairs = myPairData.front().myPairs;",
							"        physx::PxU32 nbPairs = myPairData.front().nbPairs;",
							"",
							"        for (int i = 0; i < (int)nbPairs; i++)",
							"        {",
							"            physx::PxFilterData filterData0 = pairs[i].shapes[0]->getSimulationFilterData();",
							"            physx::PxFilterData filterData1 = pairs[i].shapes[1]->getSimulationFilterData();",
							"",
							"            if (filterData0.word0 & filterData1.word1)",
							"            {",
							"                static_cast<PhysicsComponent*>(pairs[i].shapes[1]->userData)",
							"                    ->CallCollisionFunction(pairs[i].shapes[0]);",
							"            }",
							"",
							"            if (filterData1.word0 & filterData0.word1)",
							"            {",
							"                static_cast<PhysicsComponent*>(pairs[i].shapes[0]->userData)",
							"                    ->CallCollisionFunction(pairs[i].shapes[1]);",
							"            }",
							"        }",
							"        myPairData.pop();",
							"    }",
							"}"
						],
						"language": "cpp"
					},
					{
						"name": "Physics Queries & Debugging",
						"explenation": "To support development and verification of the physics system, the engine streams live simulation data to the PhysX Visual Debugger in debug builds. This provided deep visibility into the physics scene, making it possible to inspect simulation state, collision filtering, and actor behavior directly within PhysX’s tooling.\n\nIn addition to simulation and collision handling, the engine exposes filtered raycasts, sweeps, and overlap queries at the engine level. These are thin wrappers around PhysX functionality and use the same filtering setup as the simulation, ensuring consistent and predictable behavior across all physics interactions.",
						"video": {
							"name": "PhysX Debugger & In-Game Comparison",
							"link": "/media/crack_engine/physx_debug_showcase.mp4"
						}
					}
				]
			},
			{
				"name": "Debug & Event Systems",
				"explenation": "I implemented a global, static logging system that allows any part of the codebase to call `Log(std::string)` with minimal overhead. Log entries can be filtered by type, and in release builds all calls are replaced by empty functions, ensuring zero performance impact.",
				"sections": [
					{
						"name": "LineDrawer Rendering",
						"explenation": "The engine includes a 3D LineDrawer to visualize debug information such as lines and bounding boxes. All rendering, including vertex buffers and shaders, was implemented from scratch. Lines are drawn at the end of the frame so they appear above other objects.\n\nTo further improve this system these lines could quite easily be batched but I never did this as it seemed a waste of time for our small engine and it only being used for debugging purposes",
						"code": [
							"void LineDrawer::Render(DebugLine& aLine, ID3D11DeviceContext* someContext)",
							"{",
							"    UpdateVertexes(aLine);",
							"    unsigned int stride = sizeof(SimpleVertex);",
							"    unsigned int offset = 0;",
							"    someContext->IASetVertexBuffers(0, 1, myVertexBuffer.GetAddressOf(), &stride, &offset);",
							"",
							"    someContext->Draw(2, 0);",
							"}",
							"",
							"void LineDrawer::DrawAllLines()",
							"{",
							"#ifdef _DEBUG",
							"    if (myActive == false)",
							"        return;",
							"",
							"    auto* instance = GraphicsEngine::GetInstance();",
							"    auto* context = instance->GetContext();",
							"    context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINELIST);",
							"    context->IASetInputLayout(myInputLayout.Get());",
							"",
							"    context->VSSetShader(myVertexShader.Get(), nullptr, 0);",
							"    context->PSSetShader(myPixelShader.Get(), nullptr, 0);",
							"",
							"    for (int i = 0; i < myLines.size(); ++i)",
							"    {",
							"        Render(myLines[i], context);",
							"    }",
							"    myLines.clear();",
							"#endif",
							"}"
						],
						"language": "cpp"
					},
					{
						"name": "LineDrawer Showcase",
						"explenation": "The video shows the LineDrawer streaming debug lines live from the engine in a debug build.",
						"video": {
							"name": "LineDrawer Demo",
							"link": "/media/test/testLink.mp4"
						}
					}
				]
			},
			{
				"name": "Event System",
				"explenation": "The engine includes a lightweight global event system based on the observer pattern. Any system can subscribe to specific message types and receive events without direct dependencies on the sender.\n\nObservers automatically register on creation and unregister on destruction, keeping lifetime management simple and avoiding dangling references. Any number of observers can listen to the same event type, allowing systems to react independently to the same input or state change.\n\nA typical use case is input handling. When a key is pressed, a message with Type: InputKeyPressed is sent. Any system currently interested in input receives the event and can inspect the payload to determine whether it should react, for example by checking which key was pressed.\n\nMessages carry both a type and a generic payload using std::any. This allows different systems to interpret the same event differently without coupling the event system to specific gameplay logic.\n\nThe system could be extended with state-based filtering to only dispatch events to observers active in a given game state. Since the event system was used across both engine and gameplay code, this extra complexity was not necessary for the scope of the projects built with it.",
				"code": [
					"struct Message",
					"{",
					"    std::any myData;",
					"    Type myType;",
					"",
					"    Message(Type aType, std::any aData = nullptr)",
					"        : myType(aType), myData(aData) {}",
					"};",
					"",
					"EventSystem::EventSystem()",
					"{",
					"    for (size_t i = 0; i < (int)Message::Type::Count; i++)",
					"    {",
					"        myObservers.push_back(std::vector<Observer*>());",
					"    }",
					"}",
					"",
					"void EventSystem::SendMsg(const Message& aMessage)",
					"{",
					"    for (int i = 0; i < myObservers[(int)aMessage.myType].size(); i++)",
					"    {",
					"        myObservers[(int)aMessage.myType][i]->Receive(aMessage);",
					"    }",
					"}",
					"",
					"void EventSystem::Subscribe(Observer* anObserver, const Message::Type aMessageType)",
					"{",
					"    myObservers[(int)aMessageType].push_back(anObserver);",
					"}"
				],
				"language": "cpp"
			}
		]
	},
	{
		"title": "Pong",
		"displayTitle": "Web based Pong",
		"summary": "A fully playable Pong game built for the website as a hands-on way to learn React and TypeScript. The project focuses on implementing game logic, physics, and AI directly in the browser.",
		"summaryVideo": {
			"name": "TestLink",
			"link": "/media/test/testLink.mp4"
		},
		"introduction": "This project is a browser-based Pong clone developed to deepen my understanding of React and TypeScript. Rather than following tutorials, I chose to build a complete, interactive game—my preferred way of learning—focusing on game logic, rendering, and lightweight AI while keeping the experience instantly playable directly on the website.",
		"introVideo": {
			"name": "TestLink",
			"link": "/media/snabb_grabb/showcase_spes.mp4"
		},
		"devTime": "2 days",
		"engine": "React, TypeScript",
		"genre": "Pong",
		"groupSize": 1,
		"sections": [
			{
				"name": "Learning React",
				"explenation": "This little pong game was created because I wanted to learn more about react and typescript. And creating a game is my favorite way ;)\nIf your intrested keep reading or just go back up and enjoy",
				"sections": [
					{
						"name": "Implementing the math",
						"explenation": "My first step was building the physics system by creating a custom Vector2 and Collider for basic math operations. I visualized these using styled divs, without worrying about how the game was rendered—just mapping Vectors 1–100 to the screen size. This approach made implementation much easier, as rendering size could be completely ignored when developing the AI systems.",
						"code": [
							"<div",
							"  className={`${PongStyle.paddle} ${PongStyle.leftPaddle}`}",
							"  style={{",
							"    insetBlockStart: `${leftPaddle.current.collider.GetTop()}vh`,",
							"    backgroundColor: `${leftAi.current.GetModeColor()}`,",
							"  }}",
							"/>"
						],
						"language": "tsx"

					},
					{
						"name": "Drawing Lines",
						"explenation": "To make debugging easier, I added a feature that draws visual debug lines to display Vector2 positions. This greatly simplified troubleshooting throughout the project. You can still enable these lines under Additional Settings.\nThey’re rendered using standard HTML <svg> elements.",
						"code": [
							"export function drawLine(start: Vector2, end: Vector2, color: string = 'white', width: number = 4) ",
							"{",
							"    return (",
							"        <svg className=LineStyle.lineSVG width='100%' height='100%' preserveAspectRatio='none'>",
							"          <line",
							"            x1={start.x} y1={start.y} x2={end.x} y2={end.y} stroke={color} stroke-width={width} />",
							"        </svg>",
							"    )"
						],
						"language": "tsx"

					},
					{
						"name": "Implementing some AI",
						"explenation": "To keep the AI simple, I created a basic paddle class and a small state pattern. I considered making a more advanced AI but decided to keep it lightweight for a quick weekend project. The system is still flexible enough to add new states or AIs with different behaviors later on.\nAfter that, I ran into a common problem—the AI was simply too good. To fix this, I added a randomized skill level for each AI at the start of every round. Higher skill levels make the AI move more accurately and slightly faster (up to the player’s speed). This creates a nice balance, making some rounds more challenging while others feel fairer. This all being extremly lightweight meaning it can play at incredible speeds with no trouble as can be seen in this video",
						"video": {
							"name": "Fast AI",
							"link": "/media/pong/fast_pong.mp4"
						},
						"textArea": "left"
					}
				]
			}
		]
	},
	{
		"title": "Snabb_Grabb",
		"displayTitle": "Snabb Grabb",
		"summary": "A fast-paced 3D platformer inspired by Neon White, where players use a card-based movement system to speedrun through levels. Developed at TGA, the game focuses on precision, flow, and pushing for the fastest time.",
		"summaryVideo": {
			"name": "SnabbGrabbIntro",
			"link": "/media/snabb_grabb/showcase_spes.mp4"
		},
		"introduction": "Neon White is defined by its lightning-fast pace and the strategic burning of resources. In Snabb Grabb, I translated this loop into a modular state machine where every card functions as both a combat tool and a key for traversal.\n\nThis page highlights my primary focuses during the project, specifically the intersection of physics and player agency. While these sections cover the core movement and card systems, they represent a focused look at a much broader development process. This involved custom engine integration and systems architecture that supported the game's high-speed requirements.",
		"introVideo": {
			"name": "SnabbGrabbIntro",
			"link": "/media/snabb_grabb/showcase_spes.mp4"
		},
		"devTime": "10 Weeks (75%)",
		"engine": "CrackEngine, C++",
		"genre": "Card-Based Speedrunner",
		"groupSize": 13,
		"sections": [
			{
				"name": "Base Movement & Kinematic Control",
				"explenation": "The movement in Snabb Grabb is built for precision and speed. I implemented a hybrid system where the player is a component-driven entity using a PhysX Capsule Controller. By manually calculating displacement and using the PxCapsuleController::move function, I gained total control over movement curves while letting PhysX handle complex collision resolution and slope-sliding. This approach prevents the 'floaty' feel often found in purely dynamic physics simulations and ensures the movement is snappy and deterministic.",
				"sections": [
					{
						"name": "Grounded Logic & Coyote Time",
						"explenation": "The movement loop follows a specific sequence to maintain stability. Every frame, gravity is applied to the vertical axis before the grounded check. If the bitmask filters (Ground, Enemy, or Door) confirm contact, the velocity is reset to a minimal downward value to keep the controller glued to the surface. Within this same check, I manage Coyote Time by resetting a timer that allows the player a brief grace period to jump after leaving a ledge, ensuring the platforming feels fair and responsive.",
						"code": [
							"myVelocity = { 0, myVelocity.y + (myGravity * aDeltaTime), 0 };",
							"",
							"//Cayote Time",
							"if (myGroundedState & (PhysXManager::FilterGroup::eGROUND |",
							"    PhysXManager::FilterGroup::eGROUNDENEMY |",
							"    PhysXManager::FilterGroup::eDOOR))",
							"{",
							"\tmyCayoteTimer = myCayoteTime;",
							"\tmyVelocity.y = -0.01f;",
							"}",
							"else",
							"{",
							"\tmyCayoteTimer -= aDeltaTime;",
							"}",
							"",
							"//Jump input if in cayote time",
							"if (myCayoteTimer > 0 && myVelocity.y < 0 && myInputDirection.y > 0)",
							"{",
							"\tmyCayoteTimer = 0;",
							"\tmyVelocity.y = myJumpForce;",
							"}"
						],
						"language": "cpp",
						"textArea": "left"
					},
					{
						"name": "Horizontal Input & World Space",
						"explenation": "Horizontal movement is calculated by normalizing raw input and applying the player's speed variable. To ensure consistent movement regardless of the camera's orientation, I convert these local directions into world space before passing the final displacement to the controller. To improve playability and prevent the player from breaking the level flow, I implemented strict limits on both vertical falling speed and horizontal run speed. This baseline consistency is vital for the game's core platforming, though specific abilities are designed to temporarily override these limits to provide a punchy, high-velocity feel.",
						"code": [
							"//Horizontal movement",
							"Vector3f horizontalInput = { myInputDirection.x, 0, myInputDirection.z };",
							"horizontalInput.Normalize();",
							"myInputDirection.x = horizontalInput.x;",
							"myInputDirection.z = horizontalInput.z;",
							"",
							"myVelocity.x += myInputDirection.x * mySpeed;",
							"myVelocity.z += myInputDirection.z * mySpeed;",
							"",
							"myAppliedVelocity = ConvertToWorldDirection(myVelocity);",
							"float vericalSpeed = std::max(myAppliedVelocity.y, -myGravityMaxSpeed);",
							"myAppliedVelocity.y = 0;",
							"float length = std::min(myAppliedVelocity.Length(), myHorizontalMaxSpeed);",
							"myAppliedVelocity.Normalize();",
							"myAppliedVelocity *= length;"
						],
						"language": "cpp"
					},
					{
						"name": "Base Movement Showcase",
						"explenation": "This video demonstrates the base movement foundation, showing the interaction between gravity, grounded state resets, and the responsive jumping mechanics before any specialized abilities are applied.",
						"video": {
							"name": "Base Movement Showcase",
							"link": "/media/test/testLink.mp4"
						}
					}
				]
			},
			{
				"name": "Card Systems & Combat Design",
				"explenation": "Following the core loop of 'Neon White,' every card in Snabb Grabb serves a dual purpose: a weapon with limited ammunition and a powerful movement ability triggered by 'burning' the card. This gives the player multiple ways to strategize through each level, rewarding experimentation while keeping the movement mechanics tight and predictable.",
				"sections": [
					{
						"name": "Deterministic Shooting: Physics Sweeps",
						"explenation": "To ensure 100% accuracy in a high-speed environment, I replaced kinetic bullets with a sweep mechanism. When the player fires, the system performs an immediate physics sweep. If a hit is detected, the enemy is scheduled for destruction after a delay calculated from the weapon's unique bullet speed. This approach allows for entirely simulated bullets that feel physically accurate while remaining deterministic. This works effectively because the enemies in our game are static; for moving targets, more advanced predictive logic would be required to maintain this level of precision.",
						"code": [
							"INSERT CODE HERE"
						],
						"language": "cpp",
						"textArea": "left"
					},
					{
						"name": "Ability Hurtboxes & Level Routing",
						"explenation": "A core mechanic of the game is that every enemy must be defeated to pass a level. To facilitate this at high speeds, I implemented custom hurtboxes that activate during movement abilities. Hitting an enemy with these volumes results in an instant kill, allowing the player to maintain their momentum without having to slow down. \n\nThese volumes are tailored to the action, such as wide boxes for dashes or spheres for ground slams. This system is a primary tool for speedrunning, as it allows players to combine precise timing and smart movement with projectile combat to find the most efficient route through a level.",
						"video": {
							"name": "Ability Hurtbox Showcase",
							"link": "/media/snabb_grabb/hurtbox.mp4"
						}
					},
					{
						"name": "Designer Empowerment & Tuning",
						"explenation": "To empower gameplay designers in refining each ability, I ensured nearly every aspect—from dash distance and gravity scales to bullet velocity—was customizable at runtime. This flexibility allows for rapid iteration and 'live' balancing sessions, making it possible to fine-tune the addictive feel of the game without requiring code recompilation.",
						"image": {
							"name": "Designer Tuning UI",
							"link": "/media/test/ducky.png"
						}
					}
				]
			},
			{
				"name": "Movement Abilities & Level Routing",
				"explenation": "The core of the gameplay is built around mastering specialized movement abilities. By 'burning' cards, players unlock moves that transform the environment into a high-speed playground.\n\nThese abilities allow for creative routing and flow-state movement, where the challenge lies in chaining different mechanics together to find the most efficient path through a level.",
				"sections": [
					{
						"name": "Ground Slam",
						"explenation": "The Ground Slam causes the player to descend at a consistent high speed until they hit an object. To make the ability feel satisfying, I implemented a brief buildup pause on activation to convey weight and force.\n\nThis pause provides a visual tell for the spherical hurtbox that triggers on impact. This hurtbox destroys enemies and environmental objects in the landing zone, rewarding the player for aggressive vertical movement.",
						"video": {
							"name": "Ground Slam Showcase",
							"link": "/media/snabb_grabb/stomp.mp4"
						}
					},
					{
						"name": "Double Jump",
						"explenation": "Double Jumping works as a mid-air extension of the base jump. I designed it to be non-intrusive by applying an upward impulse while maintaining the player's current horizontal velocity and full input control.\n\nThis allows for precise mid-air course corrections and vertical height gains without killing the momentum of a run.",
						"video": {
							"name": "Double Jump Showcase",
							"link": "/media/snabb_grabb/Double_Jump.mp4"
						}
					},
					{
						"name": "Dashing & Momentum Falloff",
						"explenation": "I developed two distinct dashes: a straightforward horizontal dash for simpler navigation and a directional dash that provides full 3D control.\n\nA significant issue during development was that abilities would end abruptly, causing an instant halt that felt jarring. To solve this, I introduced a customizable falloff force. This force smooths out the transition back to standard movement, allowing the player to carry their speed into the next action.",
						"video": {
							"name": "Dashing Showcase",
							"link": "/media/snabb_grabb/dash.mp4"
						}
					},
					{
						"name": "Grappling Hook",
						"explenation": "The Grappling Hook uses raycasting to detect objects within range and pulls the player directly toward the hit point to provide a speed boost.\n\nThis feature opens up a multitude of creative possibilities. It serves as a reliable tool for gaining height or closing distances quickly, which is ideal for crafting a diverse range of level shortcuts.",
						"video": {
							"name": "Grapple Showcase",
							"link": "/media/snabb_grabb/grapple.mp4"
						}
					},
					{
						"name": "Teleporting",
						"explenation": "The teleport ability is restricted to targeting enemies via raycasting. Simply transporting the player to the target's position felt disorienting and lacked impact.\n\nTo address this, the ability moves the player close to the enemy and then finishes with a dashing motion. This dash provides a more engaging transition and ensures the player clearly understands they successfully hit the enemy before they move on to their next target.",
						"video": {
							"name": "Teleport Showcase",
							"link": "/media/snabb_grabb/teleport.mp4"
						}
					},
					{
						"name": "The Bomb",
						"explenation": "The Bomb is the most complex ability, repurposing the bullet sweep logic to trigger an explosion on impact. When caught in the blast, the player is propelled upward by a predetermined amount influenced by current velocity.\n\nThe horizontal displacement is determined by the player's distance from the explosion center. This distance-based calculation allows skilled players to use the blast for massive level skips and advanced routing.",
						"video": {
							"name": "Bomb Showcase",
							"link": "/media/snabb_grabb/bomb.mp4"
						}
					}
				]
			},
			{
				"name": "Project Reflection",
				"explenation": "The goal was to create an addictive gameplay loop where the challenge came from mastering physics to shave milliseconds off a run. By combining responsive movement with a simple web server for high scores, we saw a competitive atmosphere during testing. This validation showed that the core mechanics were solid, rewarding players for finding the most efficient lines through the geometry and prioritizing feel over perfect physics simulation.\n\nDeveloping these abilities was a constant collaboration with level designers. Since abilities were gated by card placement, I ensured every variable—from ground slam buildup to dash falloff distance—was tweakable at runtime. This allowed for rapid iteration, ensuring levels had a clear main path while still supporting emergent shortcuts. Looking back, I would architect the card system more modularly to simplify the player logic by decoupling ability-specific components. I would also focus more on camera detailing, such as adding a 'squish' effect when landing a slam to further emphasize the impact. While the mechanics are tight, adding this polish alongside improved VFX and UI would further bridge the gap between a technical prototype and a finished experience."
			}
		]
	},
	{
		"title": "NSH",
		"displayTitle": "Nothing Strange Here",
		"summary": "A cozy and mysterious exploration game where you play as an investigative journalist in Larcenest Gap. Explore the town, take photos, publish articles, and uncover strange secrets that influence how the town changes.",
		"summaryVideo": {
			"name": "TestLink",
			"link": "/media/test/testLink.mp4"
		},
		"introduction": "Nothing Strange Here is a cozy mystery adventure where players step into the shoes of an investigative journalist in the quirky town of Larcenest Gap. As the Lead UI/UX Designer and Programmer, I am responsible for bridge the gap between complex creative tools and a relaxing player experience. My work focuses on developing intuitive systems that allow players to capture, edit, and document their journey through a highly personalized lens.",
		"introVideo": {
			"name": "TestLink",
			"link": "https://www.youtube.com/embed/79KObxPyjOY"
		},
		"devTime": "1 year",
		"engine": "Unity, C#",
		"genre": "Cozy Photography",
		"groupSize": "9",
		"sections": []
	},
	{
		"title": "HF4",
		"displayTitle": "High Frontier 4 All",
		"summary": "A digital multiplayer adaptation of High Frontier, one of the most complex board games ever created, developed during my internship at ION Games with a focus on translating the board game’s depth into an accessible online experience.",
		"summaryVideo": {
			"name": "TestLink",
			"link": "/media/test/testLink.mp4"
		},
		"introduction": "High Frontier is a space game",
		"introVideo": {
			"name": "TestLink",
			"link": "https://www.youtube.com/embed/TE66tRzv0Kg"
		},
		"devTime": "0",
		"engine": "Unity, C#",
		"genre": "Strategy",
		"groupSize": "0",
		"sections": []
	},
	{
		"title": "Power_Valley",
		"displayTitle": "Power To The Valley",
		"summary": "A driving and scavenging game inspired by Pacific Drive, where players explore rural backroads to gather resources, developed as a student project at TGA with a strong focus on atmosphere and exploration.",
		"summaryVideo": {
			"name": "TestLink",
			"link": "/media/test/testLink.mp4"
		},
		"introduction": "High Frontier is a space game",
		"introVideo": {
			"name": "Power Valley Youtube Trailer",
			"link": "https://www.youtube.com/embed/QSF5hwfAS5Y"
		},
		"devTime": "0",
		"engine": "Unity, C#",
		"genre": "Top-down diablo-style action game",
		"groupSize": 17,
		"sections": []
	},

	{
		"title": "Spite",
		"displayTitle": "Spite: Eternal Night",
		"summary": "A Diablo-inspired action RPG set in an Incan-themed world, focused on fast-paced combat and a streamlined gameplay experience, developed as part of a student project.",
		"summaryVideo": {
			"name": "SpiteAbout",
			"link": "/media/spite/spite_about.mp4"
		},
		"introduction": "An usurpur has consumed the sun; an eternal night beckons.\nPurge the heretics; restore the solar cycle!",
		"introVideo": {
			"name": "Spite Youtube Trailer",
			"link": "https://www.youtube.com/embed/hRS8kSj9LoI"
		},
		"devTime": "5 Weeks",
		"engine": "CrackEngine, C++",
		"genre": "Top-down diablo-style action game",
		"groupSize": 14,
		"sections": []
	},
	{
		"title": "Aeon",
		"displayTitle": "Aeon",
		"summary": "A compact action game where you play as a fast and agile bird, dashing and striking to defeat towering rock golems, developed as a student project.",
		"summaryVideo": {
			"name": "SnabbGrabbIntro",
			"link": "/media/aeon/Aeon_IntroVideo.mp4"
		},
		"introduction": "Aeon is a top-down, Diablo-style action game developed using TGE, the custom engine of The Game Assembly. The story follows a small hero navigating a world where time and space have been disrupted, requiring them to battle golems and overcome environmental obstacles. As a Gameplay and Tools Programmer, I focused on building the foundational movement and collision systems that defined the player experience within the engine.",
		"introVideo": {
			"name": "Aeon Youtube Trailer",
			"link": "https://www.youtube.com/embed/TWCVsLfUN20"
		},
		"devTime": "4 Weeks",
		"engine": "TGE, C++",
		"genre": "Top-down diablo-style action game",
		"groupSize": 12,
		"sections": [
			{
				"name": "Grid Collision and Level Design Tools",
				"explenation": "The Grid Collision system was the backbone of all movement in Aeon, ensuring entities stayed within the boundaries of the game’s floating islands. To make the system accessible for the team, I implemented a simple tagging workflow that allowed level designers to apply collision logic to existing objects and change tiles during runtime. This focus on usability ensured that the technical constraints of the grid never hindered the creative process of level building.",
				"video": {
					"name": "Fast AI",
					"link": "/media/aeon/Aeon_GridCol.mp4"
				}
			},
			{
				"name": "Player Movement and Navigation",
				"explenation": "Building upon the grid system, I developed a movement set focused on fluidity and edge-case stability. My goal was to ensure that walking and dashing felt natural despite the strict underlying grid.",
				"sections": [
					{
						"name": "One of the More Interesting Challenges: Stairs",
						"explenation": "A specific challenge during development was how the player interacted with verticality. I implemented a system that utilized smooth lerping between height layers, but also accounted for side-approach logic. This allowed the player to take their first few steps onto a staircase from the side for a more natural feel, while preventing them from jumping up the entire height of the stairs from the side, which maintained the physical integrity of the level.",
						"video": {
							"name": "Fast AI",
							"link": "/media/aeon/Aeon_PlayerMov.mp4"
						}
					},
					{
						"name": "Calculated Gaps and Dashing",
						"explenation": "I designed the dash mechanic to allow for more than just horizontal movement. When a player attempts to dash over a gap, the system performs a series of point-checks in front of the character to validate potential landing spots. This ensures the player can only dash over empty space if there is a viable tile on the other side, preventing them from dashing into infinite voids while still allowing for aggressive, gap-clearing gameplay.",
						"code": [
							"INSERT CODE HERE"
						],
						"language": "tsx"
					}
				]
			},
			{
				"name": "CPU Particle System",
				"explenation": "To enhance the visual feedback of the world, I created a lightweight, CPU-based particle system. While kept simple to maximize development efficiency, it was used effectively for entity trails and environmental destruction. Most importantly, it served a gameplay purpose by providing a clear visual indicator when an enemy noticed the player, bridging the gap between art and mechanical feedback.",
				"video": {
					"name": "Fast AI",
					"link": "/media/aeon/Aeon_ParticleSys.mp4"
				}
			}
		]
	},
	{
		"title": "Donkeys_Inferno",
		"displayTitle": "Donkey's Inferno",
		"summary": "A short 2.5D platformer where you play as a donkey descending into hell. Hell-bent to get your soul back, fighting enemies and navigating hostile environments, developed as a student project.",
		"summaryVideo": {
			"name": "SnabbGrabbIntro",
			"link": "/media/test/testLink.mp4"
		},
		"introduction": "High Frontier is a space game",
		"introVideo": {
			"name": "Donkey's Inferno Youtube Trailer",
			"link": "https://www.youtube.com/embed/A5jJxE0OZMI"
		},
		"devTime": "4 Weeks",
		"engine": "TGE, C++",
		"genre": "Top-down diablo-style action game",
		"groupSize": 12,
		"sections": []
	},
	{
		"title": "Lonely_Lighthouse",
		"displayTitle": "Lonely Lighthouse",
		"summary": "Lonely Lighthouse is an atmospheric survival game developed solo for a game jam centered on the theme of Isolation. Set on a remote island, players must manage a delicate resource loop to keep a lighthouse operational while struggling against the toll of solitude. The project was recognized for its design, winning two awards during the jam, including the award for Best Theme.",
		"summaryVideo": {
			"name": "SnabbGrabbIntro",
			"link": "/media/test/testLink.mp4"
		},
		"introduction": "Lonely Lighthouse is an atmospheric survival game developed solo for a game jam centered on the theme of Isolation. Set on a remote island, players must manage a delicate resource loop to keep a lighthouse operational while struggling against the toll of solitude. The project was recognized for its design, winning two awards during the jam, including the award for Best Theme.",
		"introVideo": {
			"name": "SnabbGrabbIntro",
			"link": "/media/test/testLink.mp4"
		},
		"devTime": "20 hours",
		"engine": "Unity, C#",
		"genre": "Top-down diablo-style action game",
		"groupSize": 1,
		"sections": [
			{
				"name": "Extensible Interaction Architecture",
				"explenation": "To maximize development speed as a solo developer, I built a robust, inheritance-based interaction system. At its core is a base Interactable class, with specialized subclasses like Holdable. In this architecture, any object that can be picked up also contains the logic for consumption or usage. This allowed me to rapidly implement diverse behaviors (such as fruits providing nutrition or batteries recharging power) by simply overriding the use-method within the holdable subclass. This modular approach ensured that adding new items late in the jam did not break existing game logic."
			},
			{
				"name": "Atmospheric Cycle & Fail-States",
				"explenation": "The game features a dynamic day-night cycle driven by a rotating directional light system. I tuned the cycle to provide a 2:1 ratio of daylight to darkness, creating a grace period for resource gathering before the lighthouse becomes a critical requirement. Technically, the lighthouse acts as the primary fail-state; if the battery is not maintained through the night, the player loses. This system also drives visual feedback, illuminating ships in the distance only when the lighthouse beam is active, reinforcing the player’s purpose.",
				"video": {
					"name": "Lighthouse Spinning",
					"link": "/media/aeon/Aeon_ParticleSys.mp4"
				}
			},
			{
				"name": "Resource Balancing & Crop Growth",
				"explenation": "The core gameplay loop centers on high-stakes crop management. Each plant type is defined by variables including growth time, yield, nutritional value, and electrical recharge capacity. I implemented a scaling growth system with a UI progress overlay to provide clear feedback. This forced players into strategic decision-making: choosing between slow-growing, high-yield investment crops or quick-growing, low-yield varieties for immediate survival, creating a constant tension between long-term planning and short-term needs.",
				"video": {
					"name": "Plants growing",
					"link": "/media/aeon/Aeon_ParticleSys.mp4"
				}
			},
			{
				"name": "Reflection",
				"explenation": "Lonely Lighthouse was a lesson in scope management and focused design. Building every system independently, from the resource hierarchy to the lighting cycle, allowed me to ensure total cohesion between the mechanics and the theme. Winning two awards at the jam validated my ability to execute a complete vertical slice under pressure. If I were to revisit this project, I would implement a clear win condition or a path off the island. While the game was built to explore the difficulty of isolation, providing a 'way out' would offer a more balanced and ultimately hopeful experience for the player."
			}
		]
	}
]
