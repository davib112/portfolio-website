{"pageProps":{"project":{"title":"CrackEngine","displayTitle":"CrackEngine: Custom C++ Engine","summary":"A custom C++ game engine developed over six months by a small student team at TGA, built alongside the games that used it and improved iteratively across multiple projects.","summaryVideo":{"name":"LarmetGickAbout","link":"/portfolio-website/media/LarmetGick/Showcase_larmet.mp4"},"introduction":"CrackEngine is a custom C++ game engine developed over six months by a small TGA student team, built in parallel with several student game projects. It features a full rendering pipeline built on DirectX 11, integrated physics, flexible gameplay systems, and editor support. The engine was iteratively improved project by project, enabling rapid prototyping, reliable reuse of core systems, and efficient iteration on gameplay features.","introVideo":{"name":"LarmetGick Youtube Trailer","link":"https://www.youtube.com/embed/s16y1qExd9Q"},"devTime":"6 Months","engine":"C++","genre":"Top-down diablo-style action game","groupSize":"3-6","sections":[{"name":"GameObject–Component System","explenation":"The GameObject–Component System is the core of CrackEngine’s architecture, designed and implemented entirely by me. Inspired by Unity's component model, it allows gameplay elements to be composed flexibly: each scene consists of game objects, which can have multiple components and nested child objects. This modular system enables rapid iteration, reusable behaviors, and visual manipulation of objects directly in the editor. Components encapsulate functionality such as rendering, physics, input handling, and AI, and can be reused across different objects and projects.","sections":[{"name":"GameObject–Component Code","explenation":"This snippet demonstrates the core of the GameObject–Component System in CrackEngine. Components can be added to a GameObject dynamically using templates, and the system supports querying both single and multiple components of a given type. This design allows gameplay elements to be composed flexibly, enabling modular behaviors such as rendering, physics, AI, and input handling. The template and dynamic_cast usage ensures type safety while keeping the system generic and reusable across projects.","code":["// Adds a component of type T to this GameObject","template<typename T = Component>","void AddComponent(T* aComponent)","{","    myComponents.push_back(aComponent);","    aComponent->SetOwner(this);","}","","// Retrieves the first component of type T","template<typename T = Component>","T* GetComponent()","{","    for (auto& c : myComponents)","    {","        T* val = dynamic_cast<T*>(c);","        if (val == nullptr) continue;","        return val;","    }","    return nullptr;","}","","// Retrieves all components of type T","template<typename T = Component>","std::vector<T*> GetComponents()","{","    std::vector<T*> components;","    for (auto& c : myComponents)","    {","        T* val = dynamic_cast<T*>(c);","        if (val == nullptr) continue;","        components.push_back(val);","    }","    return components;","}"],"language":"cpp"},{"name":"GameObject–Component Diagram","explenation":"Diagram showing the hierarchy of GameObjects and Components in CrackEngine.","image":{"name":"GameObjectComponentDiagram","link":"/portfolio-website/media/crackengine/GameObjectComponentDiagram.png"}}]},{"name":"Engine Editor","explenation":"I built the editor backend for CrackEngine to support efficient development and iteration across all projects using the engine. It allows inspection and modification of GameObjects, component composition, transforms, hierarchies, and runtime states. This editor was central to the development workflow, enabling rapid iteration on enemies, player behavior, and interactive objects. The system was designed to integrate tightly with engine math, component management, and scene hierarchy.","sections":[{"name":"Debug & Line Drawer","explenation":"The editor integrates a 3D line drawing system for debugging, including custom shaders. These lines allow visualization of object positions, component data, and parent-child relationships in real-time, making scene setup and AI development easier. Debug logs are automatically excluded in release builds."},{"name":"Component Inspection","explenation":"Components can be added, inspected, and modified directly in the editor. The system supports dynamic templates, allowing developers to attach multiple component types to GameObjects, query them individually or in groups, and edit properties at runtime. This made testing and iterating on game mechanics extremely efficient."},{"name":"Component Management Example","explenation":"This snippet shows how the editor interacts with GameObjects to add and query components.","code":["THIS IS NOT A CODE SNIPPET YET ONLY A LITTLE TEST SO FAR"],"language":"cpp"},{"name":"Parent-Child & Drag-Drop","explenation":"The editor supports robust drag-and-drop workflows, both internally and from the operating system. Assets such as models and textures can be dragged directly from Windows Explorer into the editor, where they are imported and instantiated using the engine’s asset and component systems.\n\nThe hierarchy view fully supports parent–child relationships. GameObjects can be reparented via drag-and-drop, with local and world transforms recalculated automatically to preserve spatial consistency. This behavior is driven by the engine’s transform and math systems, ensuring correct position, rotation, and scale propagation across complex hierarchies rather than relying on editor-specific overrides.","video":{"name":"Gameobject Drag & Drop","link":"/portfolio-website/media/Aeon/Aeon_PlayerMov.mp4"},"textArea":"left"},{"name":"Save & Load","explenation":"The editor integrates with the engine's save/load system to persist scenes, object transforms, and component properties. All data is serialized to JSON, including hierarchical relationships, component types, and values, allowing scenes to be restored exactly as they were edited in the editor."}]},{"name":"PhysX Integration","explenation":"I implemented the PhysX foundation, scene management, and simulation loop for CrackEngine. This includes fixed-timestep simulation, robust collision filtering, and routing collision events to gameplay components. The system was designed to remain stable under fluctuating frame rates while giving gameplay systems precise control over physics interactions.","sections":[{"name":"Fixed Timestep Simulation","explenation":"The physics simulation runs with a fixed timestep, capped at 60 updates per second, while still using accumulated frame delta time. This ensures consistent physics behavior even when the game experiences frame drops or stalls. The system also supports skipping a simulation frame when needed for special gameplay events, such as respawning or scene transitions."},{"name":"PhysX Update Loop","explenation":"The PhysX scene is stepped using an accumulator-based fixed timestep. After simulation, collision data is processed and forwarded to gameplay components unless explicitly skipped for special cases.","code":["void PhysXManager::Update(float deltaTime)","{","    if (!myPxScene)","        return;","","    myAccumulator += deltaTime;","","    if (myAccumulator < myTimeStep)","        return;","","    myAccumulator -= myTimeStep;","","    myPxScene->simulate(myTimeStep);","    myPxScene->fetchResults(true);","","    // Can skip giving contact data (used for respawn)","    if (skipFrame)","    {","        std::queue<PairData> empty;","        std::swap(myPairData, empty);","        skipFrame = false;","        return;","    }","    ","    afterContact();","}"],"language":"cpp"},{"name":"Collision Dispatch","explenation":"Collision handling is performed after the physics simulation step. Contact pairs collected during simulation are filtered using PhysX filter data to determine which interactions should generate gameplay responses. This allows precise control over collision behavior while keeping gameplay systems decoupled from the physics layer.\n\nFiltered collisions are then routed to the appropriate components attached to the involved GameObjects, allowing different component types to respond to physics events without hard dependencies or tight coupling between systems.","code":["void PhysXManager::afterContact()","{","    while (!myPairData.empty())","    {","        const physx::PxContactPair* pairs = myPairData.front().myPairs;","        physx::PxU32 nbPairs = myPairData.front().nbPairs;","","        for (int i = 0; i < (int)nbPairs; i++)","        {","            physx::PxFilterData filterData0 = pairs[i].shapes[0]->getSimulationFilterData();","            physx::PxFilterData filterData1 = pairs[i].shapes[1]->getSimulationFilterData();","","            if (filterData0.word0 & filterData1.word1)","            {","                static_cast<PhysicsComponent*>(pairs[i].shapes[1]->userData)","                    ->CallCollisionFunction(pairs[i].shapes[0]);","            }","","            if (filterData1.word0 & filterData0.word1)","            {","                static_cast<PhysicsComponent*>(pairs[i].shapes[0]->userData)","                    ->CallCollisionFunction(pairs[i].shapes[1]);","            }","        }","        myPairData.pop();","    }","}"],"language":"cpp"},{"name":"Physics Queries & Debugging","explenation":"To support development and verification of the physics system, the engine streams live simulation data to the PhysX Visual Debugger in debug builds. This provided deep visibility into the physics scene, making it possible to inspect simulation state, collision filtering, and actor behavior directly within PhysX’s tooling.\n\nIn addition to simulation and collision handling, the engine exposes filtered raycasts, sweeps, and overlap queries at the engine level. These are thin wrappers around PhysX functionality and use the same filtering setup as the simulation, ensuring consistent and predictable behavior across all physics interactions.","video":{"name":"PhysX Debugger & In-Game Comparison","link":"/portfolio-website/media/CrackEngine/physx_debug_showcase.mp4"}}]},{"name":"Debug & Event Systems","explenation":"I implemented a global, static logging system that allows any part of the codebase to call `Log(std::string)` with minimal overhead. Log entries can be filtered by type, and in release builds all calls are replaced by empty functions, ensuring zero performance impact.","sections":[{"name":"LineDrawer Rendering","explenation":"The engine includes a 3D LineDrawer to visualize debug information such as lines and bounding boxes. All rendering, including vertex buffers and shaders, was implemented from scratch. Lines are drawn at the end of the frame so they appear above other objects.\n\nTo further improve this system these lines could quite easily be batched but I never did this as it seemed a waste of time for our small engine and it only being used for debugging purposes","code":["void LineDrawer::Render(DebugLine& aLine, ID3D11DeviceContext* someContext)","{","    UpdateVertexes(aLine);","    unsigned int stride = sizeof(SimpleVertex);","    unsigned int offset = 0;","    someContext->IASetVertexBuffers(0, 1, myVertexBuffer.GetAddressOf(), &stride, &offset);","","    someContext->Draw(2, 0);","}","","void LineDrawer::DrawAllLines()","{","#ifdef _DEBUG","    if (myActive == false)","        return;","","    auto* instance = GraphicsEngine::GetInstance();","    auto* context = instance->GetContext();","    context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINELIST);","    context->IASetInputLayout(myInputLayout.Get());","","    context->VSSetShader(myVertexShader.Get(), nullptr, 0);","    context->PSSetShader(myPixelShader.Get(), nullptr, 0);","","    for (int i = 0; i < myLines.size(); ++i)","    {","        Render(myLines[i], context);","    }","    myLines.clear();","#endif","}"],"language":"cpp"},{"name":"LineDrawer Showcase","explenation":"The video shows the LineDrawer streaming debug lines live from the engine in a debug build.","video":{"name":"LineDrawer Demo","link":"/portfolio-website/media/test/testLink.mp4"}}]},{"name":"Event System","explenation":"The engine includes a lightweight global event system based on the observer pattern. Any system can subscribe to specific message types and receive events without direct dependencies on the sender.\n\nObservers automatically register on creation and unregister on destruction, keeping lifetime management simple and avoiding dangling references. Any number of observers can listen to the same event type, allowing systems to react independently to the same input or state change.\n\nA typical use case is input handling. When a key is pressed, a message with Type: InputKeyPressed is sent. Any system currently interested in input receives the event and can inspect the payload to determine whether it should react, for example by checking which key was pressed.\n\nMessages carry both a type and a generic payload using std::any. This allows different systems to interpret the same event differently without coupling the event system to specific gameplay logic.\n\nThe system could be extended with state-based filtering to only dispatch events to observers active in a given game state. Since the event system was used across both engine and gameplay code, this extra complexity was not necessary for the scope of the projects built with it.","code":["struct Message","{","    std::any myData;","    Type myType;","","    Message(Type aType, std::any aData = nullptr)","        : myType(aType), myData(aData) {}","};","","EventSystem::EventSystem()","{","    for (size_t i = 0; i < (int)Message::Type::Count; i++)","    {","        myObservers.push_back(std::vector<Observer*>());","    }","}","","void EventSystem::SendMsg(const Message& aMessage)","{","    for (int i = 0; i < myObservers[(int)aMessage.myType].size(); i++)","    {","        myObservers[(int)aMessage.myType][i]->Receive(aMessage);","    }","}","","void EventSystem::Subscribe(Observer* anObserver, const Message::Type aMessageType)","{","    myObservers[(int)aMessageType].push_back(anObserver);","}"],"language":"cpp"}]}},"__N_SSG":true}